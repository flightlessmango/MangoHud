#!/usr/bin/env bash
set -euo pipefail

# Paths (adjust if your repo uses a different path)
FILES=(
  "src/config.h"
  "src/config.cpp"
  "src/font.cpp"
  "src/hud_elements.cpp"
  "src/overlay.cpp"
  "src/overlay_params.h"
)

# Back up original files
echo "Backing up files..."
for f in "${FILES[@]}"; do
  if [ -f "$f" ]; then
    cp -v "$f" "$f.orig"
  else
    echo "ERROR: Missing file $f"
    exit 1
  fi
done

# 1) Insert FontConfig and PerComponentFonts into config.h before the final #endif (or append)
CONFIG_H="src/config.h"
awk -v insert='\
/* NEW_FEATURE_START */ \
struct FontConfig { \
    std::string file;   /* font file path */ \
    int size = -1;      /* font size override (-1 = use global) */ \
    ImVec4 color = ImVec4(1.0f,1.0f,1.0f,1.0f); \
    bool uppercase = false; /* custom variables preserve case by default */ \
    void clear() { file.clear(); size = -1; color = ImVec4(1,1,1,1); uppercase = false; } \
}; \
\
/* new feature: extend overlay_config with per-component font configs */ \
struct PerComponentFonts { \
    FontConfig gpu; \
    FontConfig cpu; \
    FontConfig vram; \
    FontConfig ram; \
    FontConfig fps; \
    FontConfig frametime; \
    FontConfig vkd3d; \
    std::map<std::string, FontConfig> custom; /* custom_<name>_font entries */ \
}; \
/* NEW_FEATURE_END */' \
'{
  lines[NR] = $0
}
END{
  # Find last occurrence of "#endif" and insert before it. Otherwise append.
  idx = -1
  for (i=1;i<=NR;i++) if (lines[i] ~ /^#endif/) idx = i
  if (idx > 0) {
    for (i=1;i<idx;i++) print lines[i]
    print ""
    print insert
    print ""
    for (i=idx;i<=NR;i++) print lines[i]
  } else {
    for (i=1;i<=NR;i++) print lines[i]
    print ""
    print insert
  }
}' "$CONFIG_H" > "$CONFIG_H.tmp" && mv "$CONFIG_H.tmp" "$CONFIG_H"
echo "Updated $CONFIG_H"

# 2) Append color parser and helper to config.cpp
CONFIG_CPP="src/config.cpp"
cat >> "$CONFIG_CPP" <<'EOF'

// new feature: parse per-component font/color/size/uppercase keys
static ImVec4 parse_color_to_imvec4(const std::string &val) {
    if (val.size()>0 && val[0]=='#') {
        std::string s = val.substr(1);
        if (s.size()==6) s += "FF";
        unsigned int rgba = 0;
        std::stringstream ss; ss << std::hex << s; ss >> rgba;
        float r = ((rgba >> 24) & 0xFF) / 255.0f;
        float g = ((rgba >> 16) & 0xFF) / 255.0f;
        float b = ((rgba >> 8) & 0xFF) / 255.0f;
        float a = (rgba & 0xFF) / 255.0f;
        return ImVec4(r,g,b,a);
    }
    return ImVec4(1,1,1,1);
}

// new feature: helper to set FontConfig fields from key/value
static void set_font_cfg_from_kv(FontConfig &cfg, const std::string &prop, const std::string &value) {
    if (prop == "font" || prop == "file") cfg.file = value;
    else if (prop == "font_size" || prop == "size") {
        try { cfg.size = std::stoi(value); } catch(...) { cfg.size = -1; }
    }
    else if (prop == "color") cfg.color = parse_color_to_imvec4(value);
    else if (prop == "uppercase") {
        std::string v = value;
        for(auto &c : v) c = std::tolower(c);
        cfg.uppercase = (v == "1" || v == "true" || v == "yes");
    }
}

EOF
echo "Appended helpers to $CONFIG_CPP"

# 3) Append per-component font loader to font.cpp
FONT_CPP="src/font.cpp"
cat >> "$FONT_CPP" <<'EOF'

// new feature: load per-component fonts
void load_per_component_fonts(ImGuiIO &io, overlay_config &conf, const std::string &base_path="") {
    // new feature: helper to add a font if specified and return pointer
    auto try_add_font = [&](const std::string &file, int size)->ImFont*{
        if (file.empty()) return nullptr;
        std::string path = file;
        if (!base_path.empty() && path.size()>0 && path[0] != '/') path = base_path + "/" + path;
        ImFont* f = io.Fonts->AddFontFromFileTTF(path.c_str(), (float)size);
        if (!f && path != file) {
            // fallback: try raw filename
            f = io.Fonts->AddFontFromFileTTF(file.c_str(), (float)size);
        }
        return f;
    };

    int global_size = conf.font_size > 0 ? conf.font_size : 18;

    // new feature: attempt load per-component fonts; store pointers in conf if fields exist
    if (!conf.per_component_fonts.gpu.file.empty()) {
        ImFont* f = try_add_font(conf.per_component_fonts.gpu.file, conf.per_component_fonts.gpu.size>0?conf.per_component_fonts.gpu.size:global_size);
        (void)f; // store or use as needed
    }
    if (!conf.per_component_fonts.cpu.file.empty()) {
        ImFont* f = try_add_font(conf.per_component_fonts.cpu.file, conf.per_component_fonts.cpu.size>0?conf.per_component_fonts.cpu.size:global_size);
        (void)f;
    }
    if (!conf.per_component_fonts.vram.file.empty()) {
        ImFont* f = try_add_font(conf.per_component_fonts.vram.file, conf.per_component_fonts.vram.size>0?conf.per_component_fonts.vram.size:global_size);
        (void)f;
    }
    if (!conf.per_component_fonts.ram.file.empty()) {
        ImFont* f = try_add_font(conf.per_component_fonts.ram.file, conf.per_component_fonts.ram.size>0?conf.per_component_fonts.ram.size:global_size);
        (void)f;
    }
    if (!conf.per_component_fonts.fps.file.empty()) {
        ImFont* f = try_add_font(conf.per_component_fonts.fps.file, conf.per_component_fonts.fps.size>0?conf.per_component_fonts.fps.size:global_size);
        (void)f;
    }
    if (!conf.per_component_fonts.frametime.file.empty()) {
        ImFont* f = try_add_font(conf.per_component_fonts.frametime.file, conf.per_component_fonts.frametime.size>0?conf.per_component_fonts.frametime.size:global_size);
        (void)f;
    }
    if (!conf.per_component_fonts.vkd3d.file.empty()) {
        ImFont* f = try_add_font(conf.per_component_fonts.vkd3d.file, conf.per_component_fonts.vkd3d.size>0?conf.per_component_fonts.vkd3d.size:global_size);
        (void)f;
    }

    for (auto &kv : conf.per_component_fonts.custom) {
        const auto &cfg = kv.second;
        if (!cfg.file.empty()) {
            ImFont* f = try_add_font(cfg.file, cfg.size>0?cfg.size:global_size);
            (void)f;
        }
    }

    // Rebuild ImGui font atlas after adding fonts if required by your code path
    io.Fonts->Build();
}

EOF
echo "Appended font loader to $FONT_CPP"

# 4) Append draw helpers to hud_elements.cpp
HUD_CPP="src/hud_elements.cpp"
cat >> "$HUD_CPP" <<'EOF'

// new feature: per-component draw helpers (font & color applied per-section)
static void draw_with_font_and_color(const FontConfig *cfg, ImFont* global_font, const overlay_config &conf, const std::function<void()> &draw_func) {
    // new feature: push global font (per-component font pointers not stored in cfg by default)
    if (global_font) ImGui::PushFont(global_font);
    ImGui::PushStyleColor(ImGuiCol_Text, (cfg? cfg->color : conf.font_color));
    draw_func();
    ImGui::PopStyleColor();
    if (global_font) ImGui::PopFont();
}

// new feature: add dedicated draw functions for sections (GPU/CPU/FPS/etc.)
// You should migrate the existing per-block rendering into these functions.
static void draw_gpu_section(overlay_config &conf) {
    draw_with_font_and_color(&conf.per_component_fonts.gpu, conf.font_ptr, conf, [&](){
        // new feature: GPU section placeholder - replace with actual GPU rendering logic
        ImGui::Text("GPU: ...");
    });
}

static void draw_cpu_section(overlay_config &conf) {
    draw_with_font_and_color(&conf.per_component_fonts.cpu, conf.font_ptr, conf, [&](){
        ImGui::Text("CPU: ...");
    });
}

static void draw_fps_section(overlay_config &conf) {
    draw_with_font_and_color(&conf.per_component_fonts.fps, conf.font_ptr, conf, [&](){
        ImGui::Text("FPS: ...");
    });
}

static void draw_frametime_section(overlay_config &conf) {
    draw_with_font_and_color(&conf.per_component_fonts.frametime, conf.font_ptr, conf, [&](){
        ImGui::Text("Frametime: ...");
    });
}

static void draw_vkd3d_section(overlay_config &conf) {
    draw_with_font_and_color(&conf.per_component_fonts.vkd3d, conf.font_ptr, conf, [&](){
        ImGui::Text("VKD3D/Wine: ...");
    });
}

// new feature: draw custom variable by name (preserves case as written)
static void draw_custom_variable(overlay_config &conf, const std::string &name, const std::string &value) {
    auto it = conf.per_component_fonts.custom.find(name);
    const FontConfig *cfg = (it != conf.per_component_fonts.custom.end()) ? &it->second : nullptr;
    draw_with_font_and_color(cfg, conf.font_ptr, conf, [&](){
        ImGui::Text("%s", value.c_str());
    });
}

EOF
echo "Appended draw helpers to $HUD_CPP"

# 5) Append overlay invocation notes to overlay.cpp
OVERLAY_CPP="src/overlay.cpp"
cat >> "$OVERLAY_CPP" <<'EOF'

// new feature: call new per-section draw helpers from overlay render
// Insert these calls in the appropriate place in your render loop to render sections with per-component fonts/colors
// Example usage (place inside the ImGui frame where HUD is drawn):
// draw_gpu_section(conf);
// draw_cpu_section(conf);
// draw_fps_section(conf);
// draw_frametime_section(conf);
// draw_vkd3d_section(conf);
EOF
echo "Appended overlay invocation notes to $OVERLAY_CPP"

# 6) Add declaration to overlay_params.h
OVERLAY_PARAMS_H="src/overlay_params.h"
cat >> "$OVERLAY_PARAMS_H" <<'EOF'

// new feature: declaration for loading per-component fonts
void load_per_component_fonts(ImGuiIO &io, overlay_config &conf, const std::string &base_path="");
EOF
echo "Appended declaration to $OVERLAY_PARAMS_H"

echo "All modifications applied. Backups saved with .orig suffix. Please review changes, run your build, and commit."
echo "Suggested next steps:"
echo "  git checkout -b feature/per-component-fonts"
echo "  git add src/*"
echo "  git commit -m 'Add per-component font/color config scaffolding for MangoHud_ext'"
echo "  git push origin feature/per-component-fonts"
